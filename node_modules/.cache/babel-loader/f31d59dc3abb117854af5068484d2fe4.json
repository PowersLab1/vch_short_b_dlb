{"ast":null,"code":"/**\n * Find a zero of a univariate function.\n *\n * This is essentially the ACM algorithm 748: Enclosing Zeros of\n * Continuous Functions due to Alefeld, Potra and Shi, ACM Transactions\n * on Mathematical Software, Vol. 21, No. 3, September 1995. Although\n * the workflow should be the same, the structure of the algorithm has\n * been transformed non-trivially; instead of the authors' approach of\n * sequentially calling building blocks subprograms we implement here a\n * FSM version using one interior point determination and one bracketing\n * per iteration, thus reducing the number of temporary variables and\n * simplifying the algorithm structure. Further, this approach reduces\n * the need for external functions and error handling. The algorithm has\n * also been slightly modified.\n *\n * (This is a port of Octave's fzero implementation, by Jaroslav Hajek.)\n *\n * @author Jack Peterson (jack@tinybike.net)\n */\n\"use strict\";\n\nvar Decimal = require(\"decimal.js\");\n\nfunction unique(arr) {\n  var u = {},\n      a = [];\n\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (u.hasOwnProperty(arr[i])) continue;\n    a.push(arr[i]);\n    u[arr[i]] = 1;\n  }\n\n  return a;\n}\n\nfunction toDecimal(x) {\n  if (x && x.constructor !== Decimal) {\n    if (x.toFixed && x.toFixed.constructor === Function) x = x.toFixed();\n    x = new Decimal(x);\n  }\n\n  return x;\n}\n\nmodule.exports = function (f, bounds, options) {\n  options = options || {};\n  var mu = toDecimal(options.mu) || new Decimal(\"0.5\");\n  var eps = toDecimal(options.eps) || new Decimal(\"0.001\");\n  var tolx = toDecimal(options.tolx) || new Decimal(0);\n  var maxiter = options.maxiter || 100;\n  var maxfev = options.maxfev || maxiter;\n  var verbose = options.verbose; // The default exit flag if exceeded number of iterations.\n\n  var code = 0;\n  var niter = 0;\n  var nfev = 0;\n  var x = new Decimal(NaN);\n  var fval = new Decimal(NaN);\n  var a = new Decimal(NaN);\n  var fa = new Decimal(NaN);\n  var b = new Decimal(NaN);\n  var fb = new Decimal(NaN); // Prepare...\n\n  if (bounds === null || bounds === undefined) {\n    throw new Error(\"Initial guess required\");\n  }\n\n  if (bounds.constructor === Array && bounds.length) {\n    a = new Decimal(bounds[0].toString());\n  } else {\n    a = new Decimal(bounds.toString());\n  }\n\n  fa = toDecimal(f(a.toString()));\n  nfev = 1;\n\n  if (bounds.constructor === Array && bounds.length > 1) {\n    b = new Decimal(bounds[1].toString());\n    fb = toDecimal(f(b.toString()));\n    nfev += 1;\n  } else {\n    // Try to get b.\n    if (verbose) {\n      console.log(\"Search for an interval around\", a.toString(), \"containing a sign change:\");\n      console.log(\"count\\ta\\t\\tf(a)\\t\\t\\t\\tb\\t\\tf(b)\");\n    }\n\n    var bracketed, blist;\n    var aa = a.eq(new Decimal(0)) ? new Decimal(1) : a;\n    var tries = 0;\n\n    do {\n      blist = [aa.times(new Decimal(\"0.9\")), aa.times(new Decimal(\"1.1\")), aa.minus(new Decimal(1)), aa.plus(new Decimal(1)), aa.times(new Decimal(\"0.5\")), aa.times(new Decimal(\"1.5\")), aa.neg(), aa.times(new Decimal(2)), aa.times(new Decimal(10)).neg(), aa.times(new Decimal(10))];\n\n      for (var j = 0, len = blist.length; j < len; ++j) {\n        b = blist[j];\n        fb = toDecimal(f(b.toString()));\n\n        if (verbose) {\n          console.log(nfev + \"\\t\\t\" + aa + \"\\t\\t\" + fa + \"\\t\\t\" + b + \"\\t\\t\" + fb);\n        }\n\n        nfev += 1;\n\n        if (fa.s * fb.s <= 0) {\n          a = aa;\n          bracketed = true;\n          break;\n        }\n      }\n\n      if (!options.randomize) break;\n      aa = aa.times(new Decimal(Math.random().toString())).plus(new Decimal((Math.random() - 0.5).toString()));\n      fa = toDecimal(f(aa.toString()));\n    } while (!bracketed && ++tries < maxiter);\n  }\n\n  var u, fu;\n\n  if (b.lt(a)) {\n    u = a;\n    a = b;\n    b = u;\n    fu = fa;\n    fa = fb;\n    fb = fu;\n  }\n\n  if (fa.s * fb.s > 0) {\n    throw new Error(\"Invalid initial bracketing\");\n  }\n\n  var slope0 = fb.minus(fa).dividedBy(b.minus(a));\n\n  if (fa.eq(new Decimal(0))) {\n    b = a;\n    fb = fa;\n  } else if (fb.eq(new Decimal(0))) {\n    a = b;\n    fa = fb;\n  }\n\n  var itype = 1;\n\n  if (fa.abs().lt(fb.abs())) {\n    u = a;\n    fu = fa;\n  } else {\n    u = b;\n    fu = fb;\n  }\n\n  var d = u;\n  var e = u;\n  var fd = fu;\n  var fe = fu;\n  var mba = mu.times(b.minus(a));\n  var c, fc, df, procedure;\n\n  if (verbose) {\n    console.log(\"Search for a zero in the interval [\" + a.toString() + \", \" + b.toString() + \"]:\");\n    console.log(\"count\\tx\\t\\t\\tf(x)\\t\\t\\tprocedure\");\n    console.log(nfev + \"\\t\\t\" + a.toFixed(18) + \"\\t\" + fa.toFixed(18) + \"\\tinitial lower\");\n    console.log(nfev + \"\\t\\t\" + b.toFixed(18) + \"\\t\" + fb.toFixed(18) + \"\\tinitial upper\");\n  }\n\n  while (niter < maxiter && nfev < maxfev) {\n    switch (itype) {\n      case 1:\n        // The initial test.\n        if (b.minus(a).lte(u.abs().times(eps).times(new Decimal(2)).plus(tolx).times(new Decimal(2)))) {\n          x = u;\n          fval = fu;\n          code = 1;\n        } else {\n          if (fa.abs().lte(fb.abs().times(new Decimal(1000))) && fb.abs().lte(fa.abs().times(new Decimal(1000)))) {\n            // Secant step.\n            c = u.minus(a.minus(b).dividedBy(fa.minus(fb)).times(fu));\n            procedure = \"secant\";\n          } else {\n            // Bisection step.\n            c = a.plus(b).dividedBy(new Decimal(2));\n            procedure = \"bisection\";\n          }\n\n          d = u;\n          df = fu;\n          itype = 5;\n        }\n\n        break;\n\n      case 2:\n      case 3:\n        var l = unique([fa, fb, fd, fe]).length;\n\n        if (l === 4) {\n          // Inverse cubic interpolation.\n          var q11 = d.minus(e).times(fd).dividedBy(fe.minus(fd));\n          var q21 = b.minus(d).times(fb).dividedBy(fd.minus(fb));\n          var q31 = a.minus(b).times(fa).dividedBy(fb.minus(fa));\n          var d21 = b.minus(d).times(fd).dividedBy(fd.minus(fb));\n          var d31 = a.minus(b).times(fb).dividedBy(fb.minus(fa));\n          var q22 = d21.minus(q11).times(fb).dividedBy(fe.minus(fb));\n          var q32 = d31.minus(q21).times(fa).dividedBy(fd.minus(fa));\n          var d32 = d31.minus(q21).times(fd).dividedBy(fd.minus(fa));\n          var q33 = d32.minus(q22).times(fa).dividedBy(fe.minus(fa));\n          c = a.plus(q31).plus(q32).plus(q33);\n          procedure = \"interpolation (cubic)\";\n        }\n\n        if (l < 4 || c.minus(a).s * c.minus(b).s < 0) {\n          // Quadratic interpolation + Newton.\n          var a0 = fa;\n          var a1 = fb.minus(fa).dividedBy(b.minus(a));\n          var a2 = fd.minus(fb).dividedBy(d.minus(b)).minus(a1).dividedBy(d.minus(a)); // Modification 1\n\n          c = a.minus(a0.dividedBy(a1));\n\n          if (!a2.eq(new Decimal(0))) {\n            c = a.minus(a0.dividedBy(a1));\n            var pc, pdc;\n\n            for (var k = 0; k < itype; ++k) {\n              pc = a0.plus(a1.plus(a2.times(c.minus(b)).times(c.minus(a))));\n              pdc = a1.plus(a2.times(c.times(new Decimal(2)).minus(a).minus(b)));\n\n              if (pdc.eq(new Decimal(0))) {\n                c = a.minus(a0.dividedBy(a1));\n              } else {\n                c = c.minus(pc.dividedBy(pdc));\n              }\n            }\n          }\n\n          procedure = \"interpolation (quadratic)\";\n        }\n\n        itype++;\n        break;\n\n      case 4:\n        // Double secant step.\n        c = u.minus(b.minus(a).times(new Decimal(2)).dividedBy(fb.minus(fa)).times(fu));\n\n        if (c.minus(u).abs().gt(b.minus(a).dividedBy(new Decimal(2)))) {\n          c = b.plus(a).dividedBy(new Decimal(2));\n        }\n\n        itype = 5;\n        break;\n\n      case 5:\n        // Bisection step.\n        c = b.plus(a).dividedBy(new Decimal(2));\n        procedure = \"bisection\";\n        itype = 2;\n    } // Don't let c come too close to a or b.\n\n\n    var delta = u.abs().times(eps).plus(tolx).times(new Decimal(\"0.14\"));\n\n    if (b.minus(a).lte(delta.times(new Decimal(2)))) {\n      c = a.plus(b).dividedBy(new Decimal(2));\n    } else {\n      var s;\n\n      if (b.minus(delta).lt(c)) {\n        s = b.minus(delta);\n      } else {\n        s = c;\n      }\n\n      if (a.plus(delta).gt(s)) {\n        c = a.plus(delta);\n      } else {\n        c = s;\n      }\n    } // Calculate new point.\n\n\n    x = c;\n    fval = toDecimal(f(c.toString()));\n    fc = fval;\n    niter++;\n    nfev++;\n\n    if (verbose) {\n      console.log(nfev + \"\\t\\t\" + x.toFixed(18) + \"\\t\" + fval.toFixed(18) + \"\\t\" + procedure);\n    } // Modification 2: skip inverse cubic interpolation if non-monotonicity\n    // is detected.\n\n\n    if (fc.minus(fa).s * fc.minus(fb).s >= 0) {\n      // The new point broke monotonicity; disable inverse cubic.\n      fe = fc;\n    } else {\n      e = d;\n      fe = fd;\n    } // Bracketing\n\n\n    if (fa.s * fc.s < 0) {\n      d = b;\n      fd = fb;\n      b = c;\n      fb = fc;\n    } else if (fb.s * fc.s < 0) {\n      d = a;\n      fd = fa;\n      a = c;\n      fa = fc;\n    } else if (fc.eq(new Decimal(0))) {\n      b = c;\n      a = b;\n      fb = fc;\n      fa = fb;\n      code = 1;\n    } else {\n      // This should never happen.\n      throw new Error(\"Zero point is not bracketed\");\n    }\n\n    if (fa.abs().lt(fb.abs())) {\n      u = a;\n      fu = fa;\n    } else {\n      u = b;\n      fu = fb;\n    }\n\n    if (b.minus(a).lte(u.abs().times(eps).times(new Decimal(2)).plus(tolx))) {\n      code = 1;\n    } // Skip bisection step if successful reduction.\n\n\n    if (itype === 5 && b.minus(a).lte(mba)) {\n      itype = 2;\n    }\n\n    if (itype === 2) {\n      mba = mu.times(b.minus(a));\n    }\n  } // while\n  // Check solution for a singularity by examining slope.\n\n\n  if (code === 1) {\n    var m;\n\n    if (new Decimal(1e6).gt(new Decimal(\"0.5\").dividedBy(eps.plus(tolx)))) {\n      m = new Decimal(1e6);\n    } else {\n      m = new Decimal(\"0.5\").dividedBy(eps.plus(tolx));\n    }\n\n    if (!b.minus(a).eq(new Decimal(0)) && fb.minus(fa).dividedBy(b.minus(a)).dividedBy(slope0).gt(m)) {\n      code = -5;\n    }\n  }\n\n  return {\n    solution: x.toFixed(),\n    fval: fval.toString(),\n    code: code,\n    diagnostic: {\n      iterations: niter,\n      functionEvals: nfev,\n      bracketx: [a.toFixed(), b.toFixed()],\n      brackety: [fa.toString(), fb.toString()]\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}