{"ast":null,"code":"'use strict';\n/**\n * Makes argument to be an array if it's not\n *\n * @param input\n * @returns {Array}\n */\n\nmodule.exports.makeItArrayIfItsNot = function (input) {\n  return Object.prototype.toString.call(input) !== '[object Array]' ? [input] : input;\n};\n/**\n *\n * Utilizes bisection method to search an interval to which\n * point belongs to, then returns an index of left border\n * of the interval\n *\n * @param {Number} point\n * @param {Array} intervals\n * @returns {Number}\n */\n\n\nmodule.exports.findIntervalLeftBorderIndex = function (point, intervals) {\n  //If point is beyond given intervals\n  if (point < intervals[0]) return 0;\n  if (point > intervals[intervals.length - 1]) return intervals.length - 1; //If point is inside interval\n  //Start searching on a full range of intervals\n\n  var indexOfNumberToCompare,\n      leftBorderIndex = 0,\n      rightBorderIndex = intervals.length - 1; //Reduce searching range till it find an interval point belongs to using binary search\n\n  while (rightBorderIndex - leftBorderIndex !== 1) {\n    indexOfNumberToCompare = leftBorderIndex + Math.floor((rightBorderIndex - leftBorderIndex) / 2);\n    point >= intervals[indexOfNumberToCompare] ? leftBorderIndex = indexOfNumberToCompare : rightBorderIndex = indexOfNumberToCompare;\n  }\n\n  return leftBorderIndex;\n};","map":null,"metadata":{},"sourceType":"script"}